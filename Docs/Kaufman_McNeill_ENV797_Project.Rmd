---
title: "Forecasting Groundwater Availability in Auser Aquifer, Italy"
subtitle: "ENV 797 Final Project, Repository: https://github.com/erkaufman/TSA_Final_Proj_EKJM"
author: "Emma Kaufman and Jenn McNeill"
date: "2024-04-26"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r include=FALSE}
# load required packages
library(lubridate)
library(ggplot2)
library(forecast)  
library(Kendall)
library(tseries)
library(outliers)
library(tidyverse)
library(smooth)
library(dplyr)
library(cowplot)
library(corrplot)
library(kableExtra) 
library(gridExtra)

```

## Introduction, Motivation, Relevance, Objectives


This project focuses on predicting water availability in an Italian aquifer managed by Acea Group, a leading Italian utility operator. The group provides water services to 9 million inhabitants across Italy.

In order to best service their customers, the Acea Group must understand how much water is available in the water bodies from which they extract. Forecasting water availability in a water body is necessary to ensure daily consumption needs are met.

In 2022, the UN reported that groundwater provides “half of the volume of water withdrawn for domestic use by the global population” and that water use is expected to grow 1% per year over the next thirty years (UN, 2022). Thus, it is important to explore how much groundwater will be available in the future. If groundwater levels are forecasted to drop dramatically, these models can be used to urge for more efficient water use practices and investments into groundwater recharge strategies.

This study is focused in Italy due to the comprehensive data available in the region. The objective of the following report is to examine the best models and exogenous variables that can help accurately predict groundwater levels, in the hope that these findings offer insight about how to focus groundwater forecasting efforts in other regions across the globe.


## Dataset information


The data for this analysis were collected from the Acea Group Smart Water Analytics Competition on Kaggle [(hyperlink)](https://www.kaggle.com/c/acea-water-prediction/data). As a utility operator, they are concerned with preserving their water bodies which include a combination of water springs, lakes, rivers, and aquifers. The nine unique datasets from this kaggle competition each had different attributes and characteristics. This report focuses time series modeling and forecasting on the Auser Aquifer. The goal is to predict the amount of water in the Auser Aquifer by modeling depth to groundwater and simultaneously evaluating how rainfall and temperature may impact these predictions as exogenous variables.

The dataset for the Auser Aquifer includes daily depth to groundwater measurements (in meters) from five different wells across the north and south sectors. Wells SAL, PAG, CoS, and DIEC represent the northern unconfined portion of the aquifer, while Well LT2 represents the southern confined portion of the aquifer. The dataset also contains daily temperature data at four sites, daily rainfall data at ten sites, and daily volume data from five different water treatment facilities that extract water from this aquifer. A sample of these data are shown in Tables 1 and 2, and the units for the measurements are found in Table 3.


```{r import data, message=FALSE, warning=FALSE, include=FALSE}

getwd()

#import data set
auser_raw <- read.csv(file="./Data/Raw/Aquifer_Auser.csv", header=TRUE)

#change date to date object
auser_raw$Date <- dmy(auser_raw$Date) 

#make a new dataframe for plotting purposes
auser_depths <- auser_raw %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL,
         PAG = Depth_to_Groundwater_PAG,
         CoS = Depth_to_Groundwater_CoS,
         DIEC = Depth_to_Groundwater_DIEC) %>%
  pivot_longer(LT2:DIEC, names_to = "Well", values_to = "Depth") %>%
  select(Date, Well, Depth)

#when we look at all the series together, we see that some have values at zero
#check the tails of all data to see which wells have values at zero
tail(auser_raw$Depth_to_Groundwater_LT2,50) #has zero values
tail(auser_raw$Depth_to_Groundwater_SAL,50) #has zero values
tail(auser_raw$Depth_to_Groundwater_PAG,50) #no zero values
tail(auser_raw$Depth_to_Groundwater_CoS,50) #has zero values
tail(auser_raw$Depth_to_Groundwater_DIEC,50) #no zero values

#create a new dataframe where values of zero are converted to NA
#this makes it so that the tsclean function can remove NAs later
auser_depths_nas <- auser_raw %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL,
         PAG = Depth_to_Groundwater_PAG,
         CoS = Depth_to_Groundwater_CoS,
         DIEC = Depth_to_Groundwater_DIEC) %>%
  select(Date, LT2:DIEC) %>%
  mutate_at(vars(LT2:DIEC), ~ ifelse(. == 0, NA, .))

#create a dataframe for each well that starts at the unique first day of data
LT2_depth <- auser_depths_nas %>%
  select(Date, LT2)%>%
  slice(2860:8154)

SAL_depth <- auser_depths_nas %>%
  select(Date, SAL)%>%
  slice(3320:8154)

PAG_depth <- auser_depths_nas %>%
  select(Date, PAG)%>%
  slice(3956:8154)

CoS_depth <- auser_depths_nas %>%
  select(Date, CoS)  %>%
  slice(3614:8154)

DIEC_depth <- auser_depths_nas %>% 
  select(Date, DIEC) %>%
  slice(4687:8154) 

#create a start date object for each well
start_LT2 <- as.Date("2006-01-01")
start_SAL <- as.Date("2007-04-06")
start_PAG <- as.Date("2009-01-01")
start_CoS <- as.Date("2008-01-25")
start_DIEC <- as.Date("2011-01-02")

```

```{r raw plot, include=FALSE}

#plot all depth to groundwater series together
ggplot(auser_depths, aes(x=Date, color=Well))+
  geom_line(aes(y=Depth))+
  scale_x_date(date_breaks = "2 years", date_labels = "%Y", 
               limits = c(as.Date("2005-01-01"), as.Date("2021-07-01")),
               expand = c(0, 0))+
  xlab("Year")+
  ylab("Depth to Groundwater (m)")+
  ggtitle("Raw Data for Depth to Groundwater at Each Well")+
  theme_light()

```


```{r data head and data variables kable, echo=FALSE, warning=FALSE}

#show the head of 10 rows that do not include NAs
head_auser <- as.data.frame(auser_raw[which(complete.cases(auser_raw))[1:10], ])
head_auser$Date <- format(head_auser$Date, "%m-%d-%y")
head_auser <- t(head_auser)

kbl(head_auser[,1:5], col.names = NULL, caption="Example Auser Aquifer Data Rows 1-5") %>%
  kable_styling(font_size = 10,
                full_width = FALSE)

kbl(head_auser[,6:10], col.names = NULL, caption="Example Auser Aquifer Data Head Rows 6-10") %>%
  kable_styling(font_size = 10,
                full_width = FALSE)
```


```{r kable for variable structure, echo=FALSE, warning=FALSE}

#make character values for all of the variable names and corresponding units
Variables <- c("Date", "Rainfall_Gallicano", "Rainfall_Pontetetto", "Rainfall_Monte_Serra", "Rainfall_Orentano", "Rainfall_Borgo_a_Mozzano", "Rainfall_Piaggione", "Rainfall_Calavorno", "Rainfall_Croce_Arcana", "Rainfall_Tereglio_Coreglia_Antelminelli", "Rainfall_Fabbriche_di_Vallico", "Depth_to_Groundwater_LT2", "Depth_to_Groundwater_SAL", "Depth_to_Groundwater_PAG", "Depth_to_Groundwater_CoS", "Depth_to_Groundwater_DIEC", "Temperature_Orentano", "Temperature_Monte_Serra", "Temperature_Ponte_a_Moriano", "Temperature_Lucca_Orto_Botanico", "Volume_POL", "Volume_CC1", "Volume_CC2", "Volume_CSA", "Volume_CSAL", "Hydrometry_Monte_S_Quirico", "Hydrometry_Piaggione")
Units <- c("Date", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Meters", "Meters", "Meters", "Meters", "Meters", "Celcius", "Celcius", "Celcius", "Celcius", "Cubic Meters", "Cubic Meters", "Cubic Meters", "Cubic Meters", "Cubic Meters", "Meters", "Meters")

#make a dataframe with the variables and units
data_information <- data.frame(Variables, Units)

#print the table using kbl
kbl(data_information, caption="Acea Group Auser Aquifer Data Structure") %>%
  kable_styling(font_size = 12,
                full_width = FALSE, 
                position = "center",
                latex_options = "hold_position") %>%
  collapse_rows(column = 2, valign = "top")

```

\newpage

## Data Wrangling

Each well's depth to groundwater data were converted into time series objects after extraneous zero values towards the end of the dataset were converted into NAs. Then the tsclean() function was run to fill in the gaps of missing data with interpolated values. The resulting cleaned time series are displayed in Figure 1 below. Additionally, the daily depth measurements were averaged by month to create a monthly time series. Temperature and rainfall were also averaged by month to be used as exogenous variables in models with these monthly time series.  


```{r create ts objects for each well, warning=FALSE, include=FALSE}

#create a time series object of the values for depth to groundwater for each well
#start the time series at the same unique first day of data as above
ts_LT2 <- ts(LT2_depth[,2],start=c(2006,01,01), frequency=365)
ts_SAL <- ts(SAL_depth[,2],start=c(2007,04,06), frequency=365)
ts_PAG <- ts(PAG_depth[,2],start=c(2009,01,01), frequency=365)
ts_CoS <- ts(CoS_depth[,2], start = c(2008,01,25), frequency= 365)
ts_DIEC <- ts(DIEC_depth[,2], start = c(2011,01,02), frequency= 365)

#plot all time series together
autoplot(ts_LT2, series = "LT2")+
  autolayer(ts_SAL, series = "SAL")+
  autolayer(ts_PAG, series = "PAG")+
  autolayer(ts_CoS, series = "CoS")+
  autolayer(ts_DIEC, series = "DIEC")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Time Series of Depth to Groundwater at Each Well")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```


```{r clean time series, echo=FALSE, fig.cap="Depth to Groundwater Time Series", message=FALSE, warning=FALSE}

#run the clean function on each time series to replace NAs
ts_LT2_clean <- tsclean(ts_LT2)
ts_SAL_clean <- tsclean(ts_SAL)
ts_PAG_clean <- tsclean(ts_PAG)
ts_CoS_clean <- tsclean(ts_CoS)
ts_DIEC_clean <- tsclean(ts_DIEC)

#plot all cleaned time series together
autoplot(ts_LT2_clean, series = "LT2")+
  autolayer(ts_SAL_clean, series = "SAL")+
  autolayer(ts_PAG_clean, series = "PAG")+
  autolayer(ts_CoS_clean, series = "CoS")+
  autolayer(ts_DIEC_clean, series = "DIEC")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Cleaned Time Series of Depth to Groundwater at Each Well")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```

\newpage

## Analysis (Methods and Models)

The correlation function was run on depth to groundwater data to discern whether the depth to groundwater values at the five wells were correlated to one another. The results are displayed in Figure 2. The depth to groundwater of the four north wells were well correlated, while the southern well was weakly correlated to the others. As a result, the rest of the analysis takes a closer look at one northern well (SAL) within the unconfined region of the aquifer, and the one southern well (LT2) within the confined region of the aquifer. These two wells also had the longest time series data available, as displayed in Figure 3.


```{r correlation plots, echo=FALSE, fig.cap="Correlation of Well Depths in Auser Aquifer", fig.height=4, fig.width=4, warning=FALSE}

#looking at initial correlation of groundwater wells
auser_subset <- auser_raw %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL,
         PAG = Depth_to_Groundwater_PAG,
         CoS = Depth_to_Groundwater_CoS,
         DIEC = Depth_to_Groundwater_DIEC) %>%
  select(LT2:DIEC) %>%
  na.omit()

#how correlated are the different groundwater wells within one aquifer?
auser_correlation <- cor(auser_subset)
#corrplot(auser_correlation, method = "ellipse")
corrplot.mixed(auser_correlation, upper = "ellipse")

```

```{r , echo=FALSE, warning=FALSE, fig.cap="LT2 and SAL Time Series", message=FALSE}

#plot only the wells of interest
autoplot(ts_LT2_clean, series = "LT2")+
  autolayer(ts_SAL_clean, series = "SAL")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Cleaned Time Series of Depth to Groundwater at Each Well")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```

\newpage

The ACF and PACF for each well were then plotted using a lag time of five years to understand the seasonal pattern of the data; these results are displayed in Figure 4. Both ACF graphs display peaks and troughs at regular intervals, which is indicative of seasonality. Knowing that temperature and rainfall affect aquifer storage, it makes sense that the depth to groundwater in the aquifer changes with respect to the season.


```{r ACF and PACF for LT2, echo=FALSE, warning=FALSE, fig.cap="ACF and PACFs for Depth to Groundwater at Wells LT2 and SAL"}

#plot the ACF and PACF for south well LT2
ACF_LT2 <- plot_grid(
  autoplot(Acf(ts_LT2_clean,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_LT2_clean,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light())

#plot the ACF and PACF for north well SAL
ACF_SAL <- plot_grid(
  autoplot(Acf(ts_SAL_clean,lag.max=1825,plot=FALSE), 
           main = "TS SAL Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_SAL_clean,lag.max=1825,plot=FALSE), 
           main = "TS SAL Depth to Groundwater") + theme_light())

grid.arrange(ACF_LT2, ACF_SAL, ncol=1)

```

The decomposition of each well's depth to groundwater data is shown in Figures 5 and 6 below. This decomposition displays overall trend, seasonality, and the random components of the depth to groundwater data over time. 

```{r decomposition LT2, echo=FALSE, warning=FALSE, fig.cap="Decomposition of Depth to Groundwater at Well LT2"}

#decompose the time series for south well LT2 using additive and multiplicative methods
decompose_ts_LT2_add <- decompose(ts_LT2_clean,"additive")
plot(decompose_ts_LT2_add)

# decompose_ts_LT2_mult <- decompose(ts_LT2_clean,"multiplicative")
# plot(decompose_ts_LT2_mult)

```

```{r decomposition SAL, echo=FALSE, warning=FALSE, fig.cap="Decomposition of Depth to Groundwater at Well SAL"}

#decompose the time series for north well SAL using additive and multiplicative methods
decompose_ts_SAL_add <- decompose(ts_SAL_clean,"additive")
plot(decompose_ts_SAL_add)

# decompose_ts_SAL_mult <- decompose(ts_SAL_clean,"multiplicative")
# plot(decompose_ts_SAL_mult)
```


\newpage

According to the decomposition, both wells show upwards trending depth to groundwater values over time. The ADF and Mann-Kendall tests were run on the de-seasoned timeseries to determine the nature of these trends. The LT2 well in the confined portion of the aquifer had a stochastic trend, while the SAL well in the unconfined aquifer had a deterministic trend. A summary of the statistical tests used to determine this are seen in Table 4 below. These different trends are likely due to the fact that wells are monitoring different kinds of aquifers, confined and unconfined. 

|            | SAL North Well (confined)       | LT2 South Well (unconfined)   |
|------------|----------------------|---------------------|
| ADF Test   | p-value = 0.01       | p-value = 0.9466    |
| Result     | Reject Null          | Fail to Reject Null |
| MK Test    | p-value =\< 2.22e-16 | NA                  |
| Result     | Reject Null          | NA                  |
| Conclusion | Deterministic Trend  | Stochastic Trend    |

: Trend Conclusions from the Augmented Dickey Fuller and Mann Kendall Test Results

------------------------------------------------------------------------

```{r trend tests for LT2 and SAL, warning=FALSE, include=FALSE}

#create deseasoned time series objects
ts_LT2_deseas <- seasadj(decompose_ts_LT2_add)

plot_grid(
  autoplot(Acf(ts_LT2_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_LT2_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light())
#we do not observe much change in the ACF or PACF plots when we deseason

print(adf.test(ts_LT2_deseas))

#ADF test shows a p-value of 0.95. We fail to reject the null hypothesis. The de-seasoned series has a stochastic trend.

ts_SAL_deseas <- seasadj(decompose_ts_SAL_add)

plot_grid(
  autoplot(Acf(ts_SAL_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_SAL_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light())
#we do not observe much change in the ACF or PACF plots when we deseason

print(adf.test(ts_SAL_deseas))

#ADF test shows a p-value of 0.01. We reject the null hypothesis. The de-seasoned series does not have a stochastic trend.

#run the Mann Kendall test on the deseasoned time series
summary(MannKendall(ts_SAL_deseas))

```


```{r deseasoned time series plot to show trend, fig.cap="Trend Visualization for Deseasoned Time Series of Depth to Groundwater at Wells LT2 and SAL", message=FALSE, warning=FALSE, include=FALSE}

#Mann Kendall test p-value indicates we should reject the null hypothesis. Data has a deterministic trend.

autoplot(ts_LT2_deseas, series = "LT2")+
  autolayer(ts_SAL_deseas, series = "SAL")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Deseasoned Time Series of Depth to Groundwater")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```

```{r monthly average data wrangling, warning=FALSE, include=FALSE}

#wrangle the data to show monthly averages instead of daily data
auser_monthly <- auser_raw %>%
  select(Date:Depth_to_Groundwater_SAL, Temperature_Lucca_Orto_Botanico) %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL) %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Month) %>%
  summarize_all(mean, na.rm = TRUE)

#create a dataframe for each well that starts at the unique first month of data
LT2_depth_monthly <- auser_monthly %>%
  select(Date, LT2)%>%
  slice(95:268)

SAL_depth_monthly <- auser_monthly %>%
  select(Date, SAL)%>%
  slice(110:268)

#create time series objects for monthly averages
ts_LT2_monthly <- ts(LT2_depth_monthly[,2],start=c(2006,01,01), frequency=12)
ts_SAL_monthly <- ts(SAL_depth_monthly[,2],start=c(2007,04,01), frequency=12)

#clean time series objects for monthly averages
ts_LT2_monthly_clean <- tsclean(ts_LT2_monthly)
ts_SAL_monthly_clean <- tsclean(ts_SAL_monthly)

#plot cleaned monthly average time series
autoplot(ts_LT2_monthly_clean) +
  autolayer(ts_SAL_monthly_clean) +
  theme_light()

```

```{r subset monthly time series, warning=FALSE, include=FALSE}

# create a subset of the time series that excludes one year
n_for_month = 12
LT2_monthly_training <- subset(ts_LT2_monthly_clean, end = length(ts_LT2_monthly_clean) - n_for_month)

# create a subset of the time series that only includes the last year
LT2_monthly_testing <- subset(ts_LT2_monthly_clean, start = length(ts_LT2_monthly_clean) - n_for_month)

# create a subset of the time series that excludes one year
SAL_monthly_training <- subset(ts_SAL_monthly_clean, end = length(ts_SAL_monthly_clean) - n_for_month)

# create a subset of the time series that only includes the last year
SAL_monthly_testing <- subset(ts_SAL_monthly_clean, start = length(ts_SAL_monthly_clean) - n_for_month)

#check plots
autoplot(LT2_monthly_training)
autoplot(LT2_monthly_testing)
autoplot(SAL_monthly_training)
autoplot(SAL_monthly_testing)

```

```{r subset daily time series, warning=FALSE, include=FALSE}

# create a subset of the time series that excludes one year
n_for = 365
LT2_daily_training <- subset(ts_LT2_clean, end = length(ts_LT2_clean) - n_for)

# create a subset of the time series that only includes the last year
LT2_daily_testing <- subset(ts_LT2_clean, start = length(ts_LT2_clean) - n_for)

# create a subset of the time series that excludes one year
SAL_daily_training <- subset(ts_SAL_clean, end = length(ts_SAL_clean) - n_for)

# create a subset of the time series that only includes the last year
SAL_daily_testing <- subset(ts_SAL_clean, start = length(ts_SAL_clean) - n_for)

#check plots
# autoplot(LT2_daily_training)
# autoplot(LT2_daily_testing)
# autoplot(SAL_daily_training)
# autoplot(SAL_daily_testing)

```

Models were then fit to the daily and monthly depth to groundwater time series data for each well while holding out a year of data. Model performance was then evaluated on the final year of held out data.

The results of the Auto Sarima (SARIMA) (using monthly data), the Exponential Smoothing State Space (ETS) (daily data), the State Space Exponential Smoothing (SSES) (daily data), and the Neural Network (NN) (daily data) models compared to the observed data are shown in Figures 7 and 8 below. A summary of the model performance metrics against the held-out test data are in Tables 5 and 6. 


```{r Auto Sarima, warning=FALSE, include=FALSE}

#fit auto sarima model to LT2
auto_LT2_train <- auto.arima(LT2_monthly_training)
auto_LT2_test <- forecast(auto_LT2_train,h=12)

#plot foresting results
autoplot(auto_LT2_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima LT2") +
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_clean, series = "Original") +
  autolayer(auto_LT2_test, series = "Auto Sarima", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2") +
  theme_light()

#check the MAPE
auto_LT2_scores <- accuracy(auto_LT2_test$mean, LT2_monthly_testing)
print(auto_LT2_scores)

#fit auto sarima model to SAL
auto_SAL_train <- auto.arima(SAL_monthly_training)
auto_SAL_test <- forecast(auto_SAL_train,h=12)

#plot foresting results
autoplot(auto_SAL_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima SAL") +
  theme_light()

#plot model + observed data
autoplot(ts_SAL_monthly_clean, series = "Original") +
  autolayer(auto_SAL_test, series = "Auto Sarima", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima SAL") +
  theme_light()

#check the MAPE
auto_SAL_scores <- accuracy(auto_SAL_test$mean, SAL_monthly_testing)
print(auto_SAL_scores)

```


```{r ETS Model, warning=FALSE, include=FALSE}

# fit ETS model to LT2
ETS_LT2 <-  stlf(LT2_daily_training, h = 365)

# plot foresting results
autoplot(ETS_LT2) + 
  ylab("depth to groundwater (meters)") + 
  theme_light()

# plot model + observed data
autoplot(ts_LT2_clean, series = "Original") +
  autolayer(ETS_LT2, series = "ETS", PI = FALSE) +
  ggtitle("ETS LT2") +
  ylab("depth to groundwater (meters)") +
  theme_light()

# check the MAPE
ETS_LT2_scores <- accuracy(ETS_LT2$mean, LT2_daily_testing)
print(ETS_LT2_scores)

# fit ETS model to SAL
ETS_SAL <-  stlf(SAL_daily_training, h = 365)

# plot foresting results
autoplot(ETS_SAL) + 
  ylab("depth to groundwater (meters)") + 
  theme_light()

# plot model + observed data
autoplot(ts_SAL_clean, series = "Original") +
  autolayer(ETS_SAL, series = "ETS", PI = FALSE) +
  ggtitle("ETS SAL") +
  ylab("depth to groundwater (meters)") +
  theme_light()

# check the MAPE
ETS_SAL_scores <- accuracy(ETS_SAL$mean, SAL_daily_testing)
print(ETS_SAL_scores)

```


```{r SSES Model LT2 and SAL, warning=FALSE, include=FALSE}
# fit SSESS model to LT2 with year of holdout
SSES_LT2 <- es(ts_LT2_clean, model="ZZZ", h=n_for, holdout=TRUE)

# plot model + observed data
autoplot(ts_LT2_clean, series = "Original") +
  autolayer(SSES_LT2$fitted, series = "SSES", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  labs(title="SSES LT2 ")+
  theme_light()

# plot forecast
autoplot(ts_LT2_clean) +
  autolayer(SSES_LT2$forecast, series="SSES") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="LT2")+
  theme_light()

# check the MAPE
SSES_LT2_scores <- accuracy(SSES_LT2$forecast, LT2_daily_testing)
print(SSES_LT2_scores)

# fit SSES model to SAL
SSES_SAL <- es(ts_SAL_clean, model="ZZZ", h=n_for, holdout=TRUE)

# plot model + observed data
autoplot(ts_SAL_clean, series = "Original") +
  autolayer(SSES_SAL$fitted, series = "SSES", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  labs(title="SSES SAL")+
  theme_light()

# plot forecast
autoplot(ts_SAL_clean) +
  autolayer(SSES_SAL$forecast, series="SSES") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="SAL")+
  theme_light()

# check the MAPE
SSES_SAL_scores <- accuracy(SSES_SAL$forecast, SAL_daily_testing)
print(SSES_SAL_scores)
```


```{r NN Model LT2 and SAL, warning=FALSE, include=FALSE}
# fit NN model to LT2 with year of holdout
NN_LT2_fit <- nnetar(LT2_daily_training, p=1, P=1)

# forecast for a year to compare to test dataset 
NN_LT2_for <- forecast(NN_LT2_fit, h= 365)

#Plot model + observed data
autoplot(ts_LT2_clean) +
  autolayer(NN_LT2_fit$fitted, series="Neural Network",PI=FALSE)+
  ylab("depth to groundwater (meters)") +
  labs(title="NN p=1, P=1, LT2")+
  theme_light()

#Plot foresting results
autoplot(ts_LT2_clean) +
  autolayer(NN_LT2_for, series="NN, p=1, P=1") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="LT2")+
  theme_light()

# LT2 NN p=1, P=1 scores
NN_scores_LT2 <- accuracy(NN_LT2_for$mean,LT2_daily_testing)
print(NN_scores_LT2)

# fit NN model to SAL with year of holdout
NN_SAL_fit <- nnetar(SAL_daily_training, p=1, P=1)

# forecast for a year to compare to test dataset 
NN_SAL_for <- forecast(NN_SAL_fit, h= 365)

#Plot model + observed data
autoplot(ts_SAL_clean) +
  autolayer(NN_SAL_fit$fitted, series="Neural Network",PI=FALSE)+
  ylab("depth to groundwater (meters)") +
  labs(title="NN p=1, P=1, SAL")+
  theme_light()

#Plot foresting results
autoplot(ts_SAL_clean) +
  autolayer(NN_SAL_for, series="NN, p=1, P=1") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="SAL")+
  theme_light()

# SAL NN p=1, P=1 scores
NN_scores_SAL <- accuracy(NN_SAL_for$mean, SAL_daily_testing)
print(NN_scores_SAL)
```


```{r plot the model fits, echo=FALSE, warning=FALSE, fig.cap="Model Performance Comparisons for Well LT2"}

#make time series objects for the last two years of data
LT2_depth_end <- LT2_depth %>%
  slice(4749:5295)

SAL_depth_end <- SAL_depth %>%
  slice(4289:4835)

ts_LT2_end <- ts(LT2_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_LT2_end_clean <- tsclean(ts_LT2_end)
ts_SAL_end <- ts(SAL_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_SAL_end_clean <- tsclean(ts_SAL_end)

#LT2 forecast comparison
plot_LT2_all_for <- autoplot(ts_LT2_clean) +
  autolayer(SSES_LT2$forecast, series="SSES") +
  autolayer(ETS_LT2, series = "ETS", PI = FALSE) +
  autolayer(auto_LT2_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_LT2_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Model Performance Comparison for Well LT2")
  
#LT2 forecast comparison starting at 2019
plot_LT2_all_for_end <- autoplot(ts_LT2_end_clean) +
  autolayer(SSES_LT2$forecast, series="SSES") +
  autolayer(ETS_LT2, series = "ETS", PI = FALSE) +
  autolayer(auto_LT2_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_LT2_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Zoomed In Model Performance Comparison for Well LT2")

grid.arrange(plot_LT2_all_for, plot_LT2_all_for_end, ncol=1)

```

```{r plot the test zone, echo=FALSE, warning=FALSE, fig.cap="Model Performance Comparisons for Well SAL"}

  
#SAL forecast comparison
plot_SAL_all_for <-autoplot(ts_SAL_clean) +
  autolayer(SSES_SAL$forecast, series="SSES") +
  autolayer(ETS_SAL, series = "ETS", PI = FALSE) +
  autolayer(auto_SAL_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_SAL_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Model Performance Comparison for Well SAL")

#SAL forecast comparison starting at 2019
plot_SAL_all_for_end <- autoplot(ts_SAL_end_clean) +
  autolayer(SSES_SAL$forecast, series="SSES") +
  autolayer(ETS_SAL, series = "ETS", PI = FALSE) +
  autolayer(auto_SAL_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_SAL_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Zoomed In Model Performance Comparison for Well SAL")

grid.arrange(plot_SAL_all_for, plot_SAL_all_for_end, ncol=1)

```

\newpage

```{r Comparing Performance Metrics, warning=FALSE, include=FALSE}

#create data frame for LT2 scores
LT2_scores <- as.data.frame(rbind(auto_LT2_scores, ETS_LT2_scores, SSES_LT2_scores, NN_scores_LT2))
row.names(LT2_scores) <- c("SARIMA", "ETS", "SSES", "NN")

#create data frame for SAL scores
SAL_scores <- as.data.frame(rbind(auto_SAL_scores, ETS_SAL_scores, SSES_SAL_scores, NN_scores_SAL))
row.names(SAL_scores) <- c("SARIMA", "ETS", "SSES", "NN")

#choose LT2 model with lowest RMSE #choose a different variable here if you want
best_model_LT2 <- which.min(LT2_scores[,"RMSE"])
cat("The best LT2 Well model by RMSE is:", row.names(LT2_scores[best_model_LT2,]))  

#choose SAL model with lowest RMSE #choose a different variable here if you want
best_model_SAL <- which.min(SAL_scores[,"RMSE"])
cat("The best SAL Well model by RMSE is:", row.names(SAL_scores[best_model_SAL,]))  
```

``` {r Comparing Performance Metrics Table, warning=FALSE, echo=FALSE} 
#kbl for LT2
kbl(LT2_scores, 
      caption = "Forecast Accuracy for Seasonal Data at Well LT2",
      digits = array(5,ncol(LT2_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(LT2_scores[,"RMSE"]))

#kbl for SAL
kbl(SAL_scores, 
      caption = "Forecast Accuracy for Seasonal Data at Well SAL",
      digits = array(5,ncol(SAL_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(SAL_scores[,"RMSE"]))

```

The SARIMA model resulted in the lowest root mean square error (RMSE) for the LT2 well, and the ETS model resulted in the lowest RMSE for the SAL well. 

After these initial results, exogenous variables were incorporated into the SARIMA model to see if the performance on the hold-out data could be improved. Both rainfall and temperature were added as exogenous variables, and they both improved the model performance on the held-out data. 

The SARIMA model results with exogenous variables are seen in Figure 9 below. Tables 7 and 8 compare performance metrics of the SARIMA model without exogenous variables with the models that included rainfall and temperature. At each of the wells, the SARIMA model with temperature as an exogenous variable had the lowest RMSE and mean absolute percentage error (MAPE). 

```{r create monthly exogenous variables for Sarima, warning=FALSE, include=FALSE}

#subset columns of interest
monthly_reg <- auser_raw %>%
  select(Date:Temperature_Lucca_Orto_Botanico) %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL) %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Month) %>%
  summarize_all(mean, na.rm = TRUE) %>%
  select(Month, LT2, SAL, Temperature_Lucca_Orto_Botanico, Rainfall_Gallicano) %>%
  slice(110:268)

#create a dataframe for each regressor that starts at the unique first month of data
temp_reg_monthly <- monthly_reg %>%
  select(Month, Temperature_Lucca_Orto_Botanico)

rain_reg_monthly <- monthly_reg %>%
  select(Month, Rainfall_Gallicano)

LT2_for_reg <- monthly_reg %>%
  select(Month, LT2)

SAL_for_reg <- monthly_reg %>%
  select(Month, SAL)

#create time series objects for monthly averages
ts_LT2_monthly_reg <- tsclean(ts(LT2_for_reg[,2],start=c(2007,04,01),frequency=12))
ts_SAL_monthly_reg <- tsclean(ts(SAL_for_reg[,2],start=c(2007,04,01),frequency=12))
ts_rain_monthly_reg <- tsclean(ts(rain_reg_monthly[,2],start=c(2007,04,01),frequency=12))
ts_temp_monthly_reg <- tsclean(ts(temp_reg_monthly[,2],start=c(2007,04,01),frequency=12))

#plot time series and regressors for visualization
# autoplot(ts_LT2_monthly_reg) +
#   autolayer(ts_SAL_monthly_reg) +
#   autolayer(ts_rain_monthly_reg) +
#   autolayer(ts_temp_monthly_reg) +
#   theme_light()

```

```{r create training and testing sets with the exogenous variables, warning=FALSE, include=FALSE}

n_for_month = 12

LT2_monthly_training_reg <- subset(ts_LT2_monthly_reg, end = length(ts_LT2_monthly_reg) - n_for_month)

LT2_monthly_testing_reg <- subset(ts_LT2_monthly_reg, start = length(ts_LT2_monthly_reg) - n_for_month)

SAL_monthly_training_reg <- subset(ts_SAL_monthly_reg, end = length(ts_SAL_monthly_reg) - n_for_month)

SAL_monthly_testing_reg <- subset(ts_SAL_monthly_reg, start = length(ts_SAL_monthly_reg) - n_for_month)

rain_monthly_training_reg <- subset(ts_rain_monthly_reg, end = length(ts_rain_monthly_reg) - n_for_month)
  
rain_monthly_testing_reg <- subset(ts_rain_monthly_reg, start = length(ts_rain_monthly_reg) - n_for_month)

temp_monthly_training_reg <- subset(ts_temp_monthly_reg, end = length(ts_temp_monthly_reg) - n_for_month)
  
temp_monthly_testing_reg <- subset(ts_temp_monthly_reg, start = length(ts_temp_monthly_reg) - n_for_month)

```

```{r Sarima with exogenous variables for LT2, warning=FALSE, include=FALSE}

#LT2 auto sarima with rainfall regressor
auto_LT2_rain_reg_train <- auto.arima(LT2_monthly_training_reg, xreg=rain_monthly_training_reg)

auto_LT2_rain_reg_test <- forecast(auto_LT2_rain_reg_train, h=12,  xreg=rain_monthly_testing_reg)

#plot foresting results
autoplot(auto_LT2_rain_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima LT2 with Rainfall Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_reg, series = "Original") +
  autolayer(auto_LT2_rain_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2 with Rainfall Regressor") +
  theme_light()

#check the MAPE
auto_LT2_rain_reg_scores <- accuracy(auto_LT2_rain_reg_test$mean, LT2_monthly_testing_reg)
print(auto_LT2_rain_reg_scores)

#LT2 auto sarima with temperature regressor
auto_LT2_temp_reg_train <- auto.arima(LT2_monthly_training_reg, xreg=temp_monthly_training_reg)

auto_LT2_temp_reg_test <- forecast(auto_LT2_temp_reg_train, h=12,  xreg=temp_monthly_testing_reg)

#plot foresting results
autoplot(auto_LT2_temp_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima LT2 with Temperature Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_reg, series = "Original") +
  autolayer(auto_LT2_temp_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2 with Temperature Regressor") +
  theme_light()

#check the MAPE
auto_LT2_temp_reg_scores <- accuracy(auto_LT2_temp_reg_test$mean, LT2_monthly_testing_reg)
print(auto_LT2_temp_reg_scores)

```

```{r Sarima with exogenous variables for SAL, warning=FALSE, include=FALSE}

#SAL auto sarima with rainfall regressor
auto_SAL_rain_reg_train <- auto.arima(SAL_monthly_training_reg, xreg=rain_monthly_training_reg)

auto_SAL_rain_reg_test <- forecast(auto_SAL_rain_reg_train, h=12,  xreg=rain_monthly_testing_reg)

#plot foresting results
autoplot(auto_SAL_rain_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima SAL with Rainfall Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_SAL_monthly_reg, series = "Original") +
  autolayer(auto_SAL_rain_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima SAL with Rainfall Regressor") +
  theme_light()

#check the MAPE
auto_SAL_rain_reg_scores <- accuracy(auto_SAL_rain_reg_test$mean, SAL_monthly_testing_reg)
print(auto_SAL_rain_reg_scores)

#SAL auto sarima with temperature regressor
auto_SAL_temp_reg_train <- auto.arima(SAL_monthly_training_reg, xreg=temp_monthly_training_reg)

auto_SAL_temp_reg_test <- forecast(auto_SAL_temp_reg_train, h=12,  xreg=temp_monthly_testing_reg)

#plot foresting results
autoplot(auto_SAL_temp_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima SAL with Temperature Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_SAL_monthly_reg, series = "Original") +
  autolayer(auto_SAL_temp_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima SAL with Temperature Regressor") +
  theme_light()

#check the MAPE
auto_SAL_temp_reg_scores <- accuracy(auto_SAL_temp_reg_test$mean, SAL_monthly_testing_reg)
print(auto_SAL_temp_reg_scores)

```

```{r SARIMA comparison plots, echo=FALSE, warning=FALSE, fig.cap="SARIMA Model Improvements when Exogenous Variables are Included at Wells LT2 and SAL"}

#make time series objects for the last two years of data
LT2_depth_end <- LT2_depth %>%
  slice(4749:5295)

SAL_depth_end <- SAL_depth %>%
  slice(4289:4835)

ts_LT2_end <- ts(LT2_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_LT2_end_clean <- tsclean(ts_LT2_end)
ts_SAL_end <- ts(SAL_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_SAL_end_clean <- tsclean(ts_SAL_end)

#LT2 forecast comparison
plot_LT2_reg_compare <- autoplot(ts_LT2_end_clean) +
  autolayer(auto_LT2_test, series = "original", PI = FALSE)+
  autolayer(auto_LT2_rain_reg_test, series = "rain regressor", PI = FALSE)+
  autolayer(auto_LT2_temp_reg_test, series = "temp regressor", PI = FALSE)+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="SARIMA Model Improvements with Exogenous Variables at Well LT2")
  
#SAL forecast comparison
plot_SAL_reg_compare <- autoplot(ts_SAL_end_clean) +
  autolayer(auto_SAL_test, series = "original", PI = FALSE)+
  autolayer(auto_SAL_rain_reg_test, series = "rain regressor", PI = FALSE)+
  autolayer(auto_SAL_temp_reg_test, series = "temp regressor", PI = FALSE)+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="SARIMA Model Improvements with Exogenous Variables at Well SAL")

grid.arrange(plot_LT2_reg_compare, plot_SAL_reg_compare, ncol=1)

```

\newpage

```{r compare accuracy for all SARIMAs, warning=FALSE, include=FALSE}

#create data frame for LT2 SARIMA scores
LT2_sarima_scores <- as.data.frame(rbind(auto_LT2_scores, 
                                         auto_LT2_rain_reg_scores, 
                                         auto_LT2_temp_reg_scores))
row.names(LT2_sarima_scores) <- c("SARIMA", "SARIMA w/ RAIN", "SARIMA w/ TEMP")

#create data frame for SAL SARIMA scores
SAL_sarima_scores <- as.data.frame(rbind(auto_SAL_scores, 
                                         auto_SAL_rain_reg_scores, 
                                         auto_SAL_temp_reg_scores))
row.names(SAL_sarima_scores) <- c("SARIMA", "SARIMA w/ RAIN", "SARIMA w/ TEMP")

#choose LT2 model with lowest RMSE #choose a different variable here if you want
best_model_LT2_reg <- which.min(LT2_sarima_scores[,"RMSE"])
cat("The best LT2 Well Sarima model by RMSE is:", row.names(LT2_sarima_scores[best_model_LT2_reg,]))  

#choose SAL model with lowest RMSE #choose a different variable here if you want
best_model_SAL_reg <- which.min(SAL_sarima_scores[,"RMSE"])
cat("The best SAL Well Sarima model by RMSE is:", row.names(SAL_sarima_scores[best_model_SAL_reg,]))  
```

```{r summary tables of SARIMA models, echo=FALSE, message=FALSE, warning=FALSE}
#kbl for LT2 SARIMA
kbl(LT2_sarima_scores, 
      caption = "Forecast Accuracy for Sarima with Regressors at Well LT2",
      digits = array(5,ncol(LT2_sarima_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(LT2_sarima_scores[,"RMSE"]))

#kbl for SAL SARIMA
kbl(SAL_sarima_scores, 
      caption = "Forecast Accuracy for Sarima with Regressors at Well SAL",
      digits = array(5,ncol(SAL_sarima_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(SAL_sarima_scores[,"RMSE"]))

```

\newpage

## Summary and Conclusions

In summary, four different models were evaluated to predict depth to groundwater at two wells within confined and unconfined portions of the Auser Aquifer in Italy. These included a seasonal arima, exponential smoothing, state space exponential smoothing, and a neural network model. When exploring model performance without exogenous variables, ETS best predicted depth to groundwater in the confined aquifer, and the seasonal auto arima best predicted depth to groundwater in the unconfined aquifer, as determined by RMSE and MAPE scores on a final year of holdout data. The model performances are seen in Figures 7 and 8, and forecast accuracy metrics are displayed in Tables 5 and 6. 

Incorporating exogenous variables into the seasonal auto arima model improved model performance for both wells, as seen in Figure 9 and the forecast accuracy metrics of Tables 7 and 8. Using temperature as an exogenous variable improved model accuracy the greatest for both of the wells analyzed in this project.

The well within the unconfined aquifer (SAL) had more significant improvement in model forecast when including exogenous variables than the well within the confined aquifer (LT2). This is likely due to the fact that groundwater levels within the unconfined aquifer fluctuate with greater frequency due to climatic factors. Rain can recharge unconfined aquifers faster than confined aquifers, and extreme heat would cause more evaporation in an unconfined aquifer than a confined one. 

That being said, these climatic factors definitely influence depth to groundwater, so it makes sense that variables of temperature and rainfall both improved model performance when used as exogenous variables. There is room for further exploration of how these variables influence depth to groundwater predictions, as it is possible that there is a lag in the correlation between groundwater depth and rainfall that was unaccounted for in these models. This could be explored further in future work to improve the model even more.

Additionally, these results show that depth to groundwater is increasing with time, either stochastically or deterministically, in different portions of the aquifer, as seen in Figures 5 and 6 and Table 4. This means overall, groundwater levels are decreasing in this region. Combining these forecast models with future climate scenarios for temperature and rainfall to predict future groundwater depletion could help inform priority areas for groundwater conservation for utility companies. 

In conclusion, it is valuable to understand the role temperature and rainfall data play in improving forecast model accuracy. These findings can help utilities prioritize the data that they are collecting at their sites to more accurately predict future aquifer storage. 

 

## Bibliography

Un world water development report 2022 ‘Groundwater: Making the invisible visible.’ (n.d.). UN-Water. Retrieved April 18, 2024, from <https://www.unwater.org/news/un-world-water-development-report-2022-%E2%80%98groundwater-making-invisible-visible%E2%80%99>

Antimo Musone, Aredhel Bergström, Federico, Luisa Marotta, Maggie, Maurizio Lucchesi. (2020). Acea Smart Water Analytics. Kaggle. <https://kaggle.com/competitions/acea-water-prediction>


## Appendix

For further analysis, forecasts of the seasonal arima models one year into the future were explored to see what future groundwater availability in these two wells would look like. Issues were encountered when forecasting with temperature as an exogenous variable, as plots ended up forecasting 12 years into the future instead of 12 months. These results are valuable for around one year, but it is not advised to use these models to forecast 12 years into the future (which is why they are not included in the report). Below is the code and the resulting plots for reference.

```{r warning=FALSE, message=FALSE}

ts_LT2_monthly_reg <- tsclean(ts(LT2_for_reg[,2],start=c(2007,04,01),frequency=12))
ts_SAL_monthly_reg <- tsclean(ts(SAL_for_reg[,2],start=c(2007,04,01),frequency=12))
ts_rain_monthly_reg <- tsclean(ts(rain_reg_monthly[,2],start=c(2007,04,01),frequency=12))
ts_temp_monthly_reg <- tsclean(ts(temp_reg_monthly[,2],start=c(2007,04,01),frequency=12))

auto_LT2_future <- auto.arima(ts_LT2_monthly_reg, xreg=ts_temp_monthly_reg)

auto_LT2_future_forecast <- forecast(auto_LT2_future, h=12, xreg=ts_temp_monthly_reg)

#plot model + observed data
autoplot(ts_LT2_monthly_reg, series = "Original") +
  autolayer(auto_LT2_future_forecast, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("One Year Forecast Auto Sarima LT2 with Temperature Regressor") +
  theme_light()

auto_SAL_future <- auto.arima(ts_SAL_monthly_reg, xreg=ts_temp_monthly_reg)

auto_SAL_future_forecast <- forecast(auto_SAL_future, h=12, xreg=ts_temp_monthly_reg)

#plot model + observed data
autoplot(ts_SAL_monthly_reg, series = "Original") +
  autolayer(auto_SAL_future_forecast, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("One Year Forecast Auto Sarima SAL with Temperature Regressor") +
  theme_light()

```


```{r applying best models to the whole dataset and forecasting into the future, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
#forecast of sarima with temp for SAL a year into the future
#LT2 auto sarima with rainfall regressor
auto_SAL_temp_reg_all <- auto.arima(ts_SAL_monthly_reg, 
                                    xreg=ts_temp_monthly_reg)
auto_SAL_temp_reg_for <- forecast(auto_SAL_temp_reg_all, 
                                  h=12,  
                                  xreg=ts_temp_monthly_reg)

#forecast of sarmia with temp for LT2 a year into the future
auto_LT2_temp_reg_all <- auto.arima(ts_LT2_monthly_reg, 
                                    xreg=ts_temp_monthly_reg)
auto_LT2_temp_reg_for <- forecast(auto_LT2_temp_reg_all,
                                  h=1,
                                  xreg=ts_temp_monthly_reg)

#plotting the forecasts
autoplot(auto_LT2_temp_reg_for) + 
  ylab("depth to groundwater (meters)") + 
  theme_light()

autoplot(auto_SAL_temp_reg_for) + 
  ylab("depth to groundwater (meters)") + 
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_reg, series = "Original") +
  autolayer(auto_LT2_temp_reg_for, series = "Forecast", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2 Forecast") +
  theme_light()


```
