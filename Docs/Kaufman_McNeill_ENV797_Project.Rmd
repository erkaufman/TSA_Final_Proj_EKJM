---
title: "Kaufman_McNeill_ENV797_Project"
author: "Emma Kaufman and Jenn McNeill"
date: "2024-04-10"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r}
# load required packages
library(lubridate)
library(ggplot2)
library(forecast)  
library(Kendall)
library(tseries)
library(outliers)
library(tidyverse)
library(smooth)
library(dplyr)
library(cowplot)
library(corrplot)
library(kableExtra) 
```

#### Introduction, Motivation, Relevance, Objectives

This project focuses on predicting water availability in an Italian aquifer managed by Acea Group, a leading Italian utility operator. The group provides water services to 9 million inhabitants across Italy.

In order to best service their customers, the Acea group must understand how much water is available in the water bodies from which they extract. Forecasting water availability in a water body is necessary to ensure daily consumption needs are met.

The UN reported that groundwater provides “half of the volume of water withdrawn for domestic use by the global population” and that water use is expected to grow 1% per year over the next thirty years (UN, 2022). Thus, it is important to explore how much groundwater will be available in the future. If groundwater levels are forecasted to drop dramatically, these forecasts can be used to urge for more efficient water use practices and investments into groundwater recharge strategies.

We focused our study in Italy due to the comprehensive data we were able to access in the region. In the following report, we examine the best exogenous variables that can help accurately predict groundwater levels. We hope that these findings offer insight about how to focus groundwater forecasting efforts in other regions across the globe.

(add more about objectives?)

#### Dataset information

Provide information on how the dataset for this analysis were collected (source), the data contained in the dataset (format). Describe how you wrangled/processed your dataset to get the time series object.

Add a table that summarizes your data structure (variables, units, ranges and/or central tendencies, data source if multiple are used, etc.). This table should inserted as a `kable` function in an R chunk. Just show the first 10 rows of your data. Do not include the code used to generate your table.

The dataset for this analysis was collected from the [Acea Group Smart Water Analytics Competition on Kaggle](https://www.kaggle.com/c/acea-water-prediction/data). As a utility operator, they are concerned with preserving their water bodies which include a combination of water springs, lakes, rivers, and aquifers. The nine unique datasets from this kaggle competition each had different attributes and characteristics. For our final project, we focused our time series modeling and forecasting on the Auser Aquifer. Our objective is to predict the amount of water in the Auser Aquifer by modeling the depth to groundwater and simultaneously evaluating how rainfall and temperature may impact our predictions as exogenous variables.

The dataset for the Auser Aquifer includes daily depth to groundwater measurements (in meters) from five different wells across the north and south sectors. Wells SAL, PAG, CoS, and DIEC represent the northern unconfined portion while Well LT2 represents the southern confined portion. We also have daily temperature data at four sites, daily rainfall data at ten sites, and daily volume data from five different water treatment facilities.

```{r import data, echo=FALSE, fig.cap="Figure 1. Raw Depth to Groundwater Series"}

getwd()

#import data set
auser_raw <- read.csv(file="./Data/Raw/Aquifer_Auser.csv", header=TRUE)

#change date to date object
auser_raw$Date <- dmy(auser_raw$Date) 

#make a new dataframe for plotting purposes
auser_depths <- auser_raw %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL,
         PAG = Depth_to_Groundwater_PAG,
         CoS = Depth_to_Groundwater_CoS,
         DIEC = Depth_to_Groundwater_DIEC) %>%
  pivot_longer(LT2:DIEC, names_to = "Well", values_to = "Depth") %>%
  select(Date, Well, Depth)

#plot all depth to groundwater series together
ggplot(auser_depths, aes(x=Date, color=Well))+
  geom_line(aes(y=Depth))+
  scale_x_date(date_breaks = "2 years", date_labels = "%Y", 
               limits = c(as.Date("2005-01-01"), as.Date("2021-07-01")),
               expand = c(0, 0))+
  xlab("Year")+
  ylab("Depth to Groundwater (m)")+
  ggtitle("Raw Data for Depth to Groundwater at Each Well")+
  theme_light()

#when we look at all the series together, we see that some have values at zero
#check the tails of all data to see which wells have values at zero
tail(auser_raw$Depth_to_Groundwater_LT2,50) #has zero values
tail(auser_raw$Depth_to_Groundwater_SAL,50) #has zero values
tail(auser_raw$Depth_to_Groundwater_PAG,50) #no zero values
tail(auser_raw$Depth_to_Groundwater_CoS,50) #has zero values
tail(auser_raw$Depth_to_Groundwater_DIEC,50) #no zero values

#create a new dataframe where values of zero are converted to NA
#this makes it so that the tsclean function can remove NAs later
auser_depths_nas <- auser_raw %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL,
         PAG = Depth_to_Groundwater_PAG,
         CoS = Depth_to_Groundwater_CoS,
         DIEC = Depth_to_Groundwater_DIEC) %>%
  select(Date, LT2:DIEC) %>%
  mutate_at(vars(LT2:DIEC), ~ ifelse(. == 0, NA, .))

#create a dataframe for each well that starts at the unique first day of data
LT2_depth <- auser_depths_nas %>%
  select(Date, LT2)%>%
  slice(2860:8154)

SAL_depth <- auser_depths_nas %>%
  select(Date, SAL)%>%
  slice(3320:8154)

PAG_depth <- auser_depths_nas %>%
  select(Date, PAG)%>%
  slice(3956:8154)

CoS_depth <- auser_depths_nas %>%
  select(Date, CoS)  %>%
  slice(3614:8154)

DIEC_depth <- auser_depths_nas %>% 
  select(Date, DIEC) %>%
  slice(4687:8154) 

#create a start date object for each well
start_LT2 <- as.Date("2006-01-01")
start_SAL <- as.Date("2007-04-06")
start_PAG <- as.Date("2009-01-01")
start_CoS <- as.Date("2008-01-25")
start_DIEC <- as.Date("2011-01-02")

```

```{r data head and data variables kable, echo=FALSE}

#show the head of 10 rows that do not include NAs
head_auser <- as.data.frame(auser_raw[which(complete.cases(auser_raw))[1:10], ])
head_auser$Date <- format(head_auser$Date, "%m-%d-%y")
head_auser <- t(head_auser)
kbl(head_auser, col.names = NULL, caption="Auser Aquifer Data Head 10 Rows") %>%
  kable_styling(font_size = 12,
                full_width = FALSE)

#make character values for all of the variable names and corresponding units
Variables <- c("Date", "Rainfall_Gallicano", "Rainfall_Pontetetto", "Rainfall_Monte_Serra", "Rainfall_Orentano", "Rainfall_Borgo_a_Mozzano", "Rainfall_Piaggione", "Rainfall_Calavorno", "Rainfall_Croce_Arcana", "Rainfall_Tereglio_Coreglia_Antelminelli", "Rainfall_Fabbriche_di_Vallico", "Depth_to_Groundwater_LT2", "Depth_to_Groundwater_SAL", "Depth_to_Groundwater_PAG", "Depth_to_Groundwater_CoS", "Depth_to_Groundwater_DIEC", "Temperature_Orentano", "Temperature_Monte_Serra", "Temperature_Ponte_a_Moriano", "Temperature_Lucca_Orto_Botanico", "Volume_POL", "Volume_CC1", "Volume_CC2", "Volume_CSA", "Volume_CSAL", "Hydrometry_Monte_S_Quirico", "Hydrometry_Piaggione")
Units <- c("Date", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Millimeters", "Meters", "Meters", "Meters", "Meters", "Meters", "Celcius", "Celcius", "Celcius", "Celcius", "Cubic Meters", "Cubic Meters", "Cubic Meters", "Cubic Meters", "Cubic Meters", "Meters", "Meters")

#make a dataframe with the variables and units
data_information <- data.frame(Variables, Units)

#print the table using kbl
kbl(data_information, caption="Acea Group Auser Aquifer Data Structure") %>%
  kable_styling(font_size = 12,
                full_width = FALSE, 
                position = "center",
                latex_options = "hold_position") %>%
  collapse_rows(column = 2, valign = "top")

```

The first obstacle with wrangling our data came when we realized that the data for each variable started at a different date. We found this issue by plotting the five depth to groundwater lines and seeing a large lag before the data started, NA values within each series, and a few random "zero" values that we assumed to be errors. To rectify this issue, we converted all "zero" values to NA, found the start date for each well's data, and then converted each well's data into a time series object. When we plotted these five time series together, we still had gaps of NA data. We ran the tsclean() function to fill in the gaps of missing data with interpolated values and then had five clean series with no data gaps.

```{r create ts objects for each well, include=FALSE}

#create a time series object of the values for depth to groundwater for each well
#start the time series at the same unique first day of data as above
ts_LT2 <- ts(LT2_depth[,2],start=c(2006,01,01), frequency=365)
ts_SAL <- ts(SAL_depth[,2],start=c(2007,04,06), frequency=365)
ts_PAG <- ts(PAG_depth[,2],start=c(2009,01,01), frequency=365)
ts_CoS <- ts(CoS_depth[,2], start = c(2008,01,25), frequency= 365)
ts_DIEC <- ts(DIEC_depth[,2], start = c(2011,01,02), frequency= 365)

#plot all time series together
autoplot(ts_LT2, series = "LT2")+
  autolayer(ts_SAL, series = "SAL")+
  autolayer(ts_PAG, series = "PAG")+
  autolayer(ts_CoS, series = "CoS")+
  autolayer(ts_DIEC, series = "DIEC")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Time Series of Depth to Groundwater at Each Well")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```

```{r clean time series, echo=FALSE, fig.cap="Figure 1. Depth to Groundwater Time Series"}

#run the clean function on each time series to replace NAs
ts_LT2_clean <- tsclean(ts_LT2)
ts_SAL_clean <- tsclean(ts_SAL)
ts_PAG_clean <- tsclean(ts_PAG)
ts_CoS_clean <- tsclean(ts_CoS)
ts_DIEC_clean <- tsclean(ts_DIEC)

#plot all cleaned time series together
autoplot(ts_LT2_clean, series = "LT2")+
  autolayer(ts_SAL_clean, series = "SAL")+
  autolayer(ts_PAG_clean, series = "PAG")+
  autolayer(ts_CoS_clean, series = "CoS")+
  autolayer(ts_DIEC_clean, series = "DIEC")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Cleaned Time Series of Depth to Groundwater at Each Well")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```

```{r , echo=FALSE, fig.cap="Figure 2. LT2 and SAL Time Series"}

#plot only the wells of interest
autoplot(ts_LT2_clean, series = "LT2")+
  autolayer(ts_SAL_clean, series = "SAL")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Cleaned Time Series of Depth to Groundwater at Each Well")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```


#### Analysis (Methods and Models)

Describe the analysis and tests that were performed. Described the components of the time series you identified. List any packages and functions used. Include visualizations of your dataset (i.e. time series plot, ACF, PACF, etc).

Format your R chunks so that graphs are displayed but code is not displayed. Accompany these graphs with text sections that describe the visualizations and provide context for further analyses.

Each figure should be accompanied by a caption, and referenced within the text if applicable.

The first step of analysis that we performed was running the correlation function on our depth to groundwater data to discern whether the depth to groundwater values at the five wells were correlated to one another. We found that the four north wells had similar correlation values to one another and that the one south well was weakly correlated to the others. Because there were not strong correlations between the wells, we decided to focus the rest of our analysis on one north, confined well (SAL) and one south, unconfined well (LT2). These two wells had the most complete time series data.

```{r correlation plots}

#looking at initial correlation of groundwater wells
auser_subset <- auser_raw %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL,
         PAG = Depth_to_Groundwater_PAG,
         CoS = Depth_to_Groundwater_CoS,
         DIEC = Depth_to_Groundwater_DIEC) %>%
  select(LT2:DIEC) %>%
  na.omit()

#how correlated are the different groundwater wells within one aquifer?
auser_correlation <- cor(auser_subset)
corrplot(auser_correlation, method = "ellipse")
corrplot.mixed(auser_correlation, upper = "ellipse")

```

We plotted the ACF and PACF for each well using a lag time of five years to get a sense for whether our data had seasonal patterns. Both ACF graphs show peaks and troughs at regular intervals, so we know that our data has yearly seasonality. Knowing what we know about temperature and rainfall affecting aquifer storage, it makes sense that the depth to groundwater in the aquifer is changing with respect to the season.

```{r }

#plot the ACF and PACF for south well LT2
plot_grid(
  autoplot(Acf(ts_LT2_clean,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_LT2_clean,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light())

#plot the ACF and PACF for north well SAL
plot_grid(
  autoplot(Acf(ts_SAL_clean,lag.max=1825,plot=FALSE), 
           main = "TS SAL Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_SAL_clean,lag.max=1825,plot=FALSE), 
           main = "TS SAL Depth to Groundwater") + theme_light())

```

In order to visualize our data in another way, we decomposed the time series for each well into its seasonal, trend, and random components using the decompose() function with both the additive and multiplicative methods. \*\*WRITE SOMETHING ABOUT CHOOSING WHICH METHOD IS BETTER MOVING FORWARD? OR MAYBE JUST REMOVE WHICHEVER ONE WE DECIDE TO NOT USE?

```{r}

#decompose the time series for south well LT2 using additive and multiplicative methods
decompose_ts_LT2_add <- decompose(ts_LT2_clean,"additive")
plot(decompose_ts_LT2_add)

decompose_ts_LT2_mult <- decompose(ts_LT2_clean,"multiplicative")
plot(decompose_ts_LT2_mult)

#decompose the time series for north well SAL using additive and multiplicative methods
decompose_ts_SAL_add <- decompose(ts_SAL_clean,"additive")
plot(decompose_ts_SAL_add)

decompose_ts_SAL_mult <- decompose(ts_SAL_clean,"multiplicative")
plot(decompose_ts_SAL_mult)

```

According to the decomposition, both of our wells showed depth to groundwater values that trended upwards over time. To model our data, we felt it was important to understand whether the trends were monotonic or stochastic. To arrive at an answer, we deseasoned the time series and then ran tests on them to classify their trends. The LT2 well in the confined portion of the aquifer turned out to have a stochastic trend, while the SAL well in the unconfined aquifer turned out to have a deterministic trend.

|            | SAL North Well       | LT2 South Well      |
|------------|----------------------|---------------------|
| ADF Test   | p-value = 0.01       | p-value = 0.9466    |
| Result     | Reject Null          | Fail to Reject Null |
| MK Test    | p-value =\< 2.22e-16 | NA                  |
| Result     | Reject Null          | NA                  |
| Conclusion | Deterministic Trend  | Stochastic Trend    |

: Trend Conclusions from the Augmented Dickey Fuller and Mann Kendall Test Results

------------------------------------------------------------------------

```{r}

#create deseasoned time series objects
ts_LT2_deseas <- seasadj(decompose_ts_LT2_add)

plot_grid(
  autoplot(Acf(ts_LT2_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_LT2_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light())
#we do not observe much change in the ACF or PACF plots when we deseason

print(adf.test(ts_LT2_deseas))

#ADF test shows a p-value of 0.95. We fail to reject the null hypothesis. The de-seasoned series has a stochastic trend.

ts_SAL_deseas <- seasadj(decompose_ts_SAL_add)

plot_grid(
  autoplot(Acf(ts_SAL_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light(),
  autoplot(Pacf(ts_SAL_deseas,lag.max=1825,plot=FALSE), 
           main = "TS LT2 Depth to Groundwater") + theme_light())
#we do not observe much change in the ACF or PACF plots when we deseason

print(adf.test(ts_SAL_deseas))

#ADF test shows a p-value of 0.01. We reject the null hypothesis. The de-seasoned series does not have a stochastic trend.

#run the Mann Kendall test on the deseasoned time series
summary(MannKendall(ts_SAL_deseas))

#Mann Kendall test p-value indicates we should reject the null hypothesis. Data has a deterministic trend.

autoplot(ts_LT2_deseas, series = "LT2")+
  autolayer(ts_SAL_deseas, series = "SAL")+
  labs(x = "Year", y = "Depth to Groundwater (m)", color = "Well")+
  theme_light()+
  ggtitle("Deseasoned Time Series of Depth to Groundwater")+
  scale_x_continuous(name = "Year", breaks = seq(from=2006, to=2022, by=2))+
  scale_y_continuous(name = "Depth to Groundwater (m)", 
                     breaks = seq(from=-16, to=0, by=2))

```

```{r monthly average data wrangling}

#wrangle the data to show monthly averages instead of daily data
auser_monthly <- auser_raw %>%
  select(Date:Depth_to_Groundwater_SAL, Temperature_Lucca_Orto_Botanico) %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL) %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Month) %>%
  summarize_all(mean, na.rm = TRUE)

#create a dataframe for each well that starts at the unique first month of data
LT2_depth_monthly <- auser_monthly %>%
  select(Date, LT2)%>%
  slice(95:268)

SAL_depth_monthly <- auser_monthly %>%
  select(Date, SAL)%>%
  slice(110:268)

#create time series objects for monthly averages
ts_LT2_monthly <- ts(LT2_depth_monthly[,2],start=c(2006,01,01), frequency=12)
ts_SAL_monthly <- ts(SAL_depth_monthly[,2],start=c(2007,04,01), frequency=12)

#clean time series objects for monthly averages
ts_LT2_monthly_clean <- tsclean(ts_LT2_monthly)
ts_SAL_monthly_clean <- tsclean(ts_SAL_monthly)

#plot cleaned monthly average time series
autoplot(ts_LT2_monthly_clean) +
  autolayer(ts_SAL_monthly_clean) +
  theme_light()

```

```{r subset monthly time series}

# create a subset of the time series that excludes one year
n_for_month = 12
LT2_monthly_training <- subset(ts_LT2_monthly_clean, end = length(ts_LT2_monthly_clean) - n_for_month)

# create a subset of the time series that only includes the last year
LT2_monthly_testing <- subset(ts_LT2_monthly_clean, start = length(ts_LT2_monthly_clean) - n_for_month)

# create a subset of the time series that excludes one year
SAL_monthly_training <- subset(ts_SAL_monthly_clean, end = length(ts_SAL_monthly_clean) - n_for_month)

# create a subset of the time series that only includes the last year
SAL_monthly_testing <- subset(ts_SAL_monthly_clean, start = length(ts_SAL_monthly_clean) - n_for_month)

#check plots
autoplot(LT2_monthly_training)
autoplot(LT2_monthly_testing)
autoplot(SAL_monthly_training)
autoplot(SAL_monthly_testing)

```

```{r subset daily time series}

# create a subset of the time series that excludes one year
n_for = 365
LT2_daily_training <- subset(ts_LT2_clean, end = length(ts_LT2_clean) - n_for)

# create a subset of the time series that only includes the last year
LT2_daily_testing <- subset(ts_LT2_clean, start = length(ts_LT2_clean) - n_for)

# create a subset of the time series that excludes one year
SAL_daily_training <- subset(ts_SAL_clean, end = length(ts_SAL_clean) - n_for)

# create a subset of the time series that only includes the last year
SAL_daily_testing <- subset(ts_SAL_clean, start = length(ts_SAL_clean) - n_for)

#check plots
# autoplot(LT2_daily_training)
# autoplot(LT2_daily_testing)
# autoplot(SAL_daily_training)
# autoplot(SAL_daily_testing)

```

Once we analyzed the time series, we were ready to start fitting models. Our process for fitting models was to fit four models on each well by holding out a year of data. The following section shows the results of testing the four models against the actual time series values for the final year.

##### SARIMA

```{r Auto Sarima}

#fit auto sarima model to LT2
auto_LT2_train <- auto.arima(LT2_monthly_training)
auto_LT2_test <- forecast(auto_LT2_train,h=12)

#plot foresting results
autoplot(auto_LT2_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima LT2") +
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_clean, series = "Original") +
  autolayer(auto_LT2_test, series = "Auto Sarima", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2") +
  theme_light()

#check the MAPE
auto_LT2_scores <- accuracy(auto_LT2_test$mean, LT2_monthly_testing)
print(auto_LT2_scores)

#fit auto sarima model to SAL
auto_SAL_train <- auto.arima(SAL_monthly_training)
auto_SAL_test <- forecast(auto_SAL_train,h=12)

#plot foresting results
autoplot(auto_SAL_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima SAL") +
  theme_light()

#plot model + observed data
autoplot(ts_SAL_monthly_clean, series = "Original") +
  autolayer(auto_SAL_test, series = "Auto Sarima", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima SAL") +
  theme_light()

#check the MAPE
auto_SAL_scores <- accuracy(auto_SAL_test$mean, SAL_monthly_testing)
print(auto_SAL_scores)

```

##### ETS

```{r ETS Model}

# fit ETS model to LT2
ETS_LT2 <-  stlf(LT2_daily_training, h = 365)

# plot foresting results
autoplot(ETS_LT2) + 
  ylab("depth to groundwater (meters)") + 
  theme_light()

# plot model + observed data
autoplot(ts_LT2_clean, series = "Original") +
  autolayer(ETS_LT2, series = "ETS", PI = FALSE) +
  ggtitle("ETS LT2") +
  ylab("depth to groundwater (meters)") +
  theme_light()

# check the MAPE
ETS_LT2_scores <- accuracy(ETS_LT2$mean, LT2_daily_testing)
print(ETS_LT2_scores)

# fit ETS model to SAL
ETS_SAL <-  stlf(SAL_daily_training, h = 365)

# plot foresting results
autoplot(ETS_SAL) + 
  ylab("depth to groundwater (meters)") + 
  theme_light()

# plot model + observed data
autoplot(ts_SAL_clean, series = "Original") +
  autolayer(ETS_SAL, series = "ETS", PI = FALSE) +
  ggtitle("ETS SAL") +
  ylab("depth to groundwater (meters)") +
  theme_light()

# check the MAPE
ETS_SAL_scores <- accuracy(ETS_SAL$mean, SAL_daily_testing)
print(ETS_SAL_scores)

```

##### SSES

```{r SSES Model LT2 and SAL}
# fit SSESS model to LT2 with year of holdout
SSES_LT2 <- es(ts_LT2_clean, model="ZZZ", h=n_for, holdout=TRUE)

# plot model + observed data
autoplot(ts_LT2_clean, series = "Original") +
  autolayer(SSES_LT2$fitted, series = "SSES", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  labs(title="SSES LT2 ")+
  theme_light()

# plot forecast
autoplot(ts_LT2_clean) +
  autolayer(SSES_LT2$forecast, series="SSES") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="LT2")+
  theme_light()

# check the MAPE
SSES_LT2_scores <- accuracy(SSES_LT2$forecast, LT2_daily_testing)
print(SSES_LT2_scores)

# fit SSES model to SAL
SSES_SAL <- es(ts_SAL_clean, model="ZZZ", h=n_for, holdout=TRUE)

# plot model + observed data
autoplot(ts_SAL_clean, series = "Original") +
  autolayer(SSES_SAL$fitted, series = "SSES", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  labs(title="SSES SAL")+
  theme_light()

# plot forecast
autoplot(ts_SAL_clean) +
  autolayer(SSES_SAL$forecast, series="SSES") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="SAL")+
  theme_light()

# check the MAPE
SSES_SAL_scores <- accuracy(SSES_SAL$forecast, SAL_daily_testing)
print(SSES_SAL_scores)
```

##### Neural Network

```{r NN Model LT2 and SAL}
# fit NN model to LT2 with year of holdout
NN_LT2_fit <- nnetar(LT2_daily_training, p=1, P=1)

# forecast for a year to compare to test dataset 
NN_LT2_for <- forecast(NN_LT2_fit, h= 365)

#Plot model + observed data
autoplot(ts_LT2_clean) +
  autolayer(NN_LT2_fit$fitted, series="Neural Network",PI=FALSE)+
  ylab("depth to groundwater (meters)") +
  labs(title="NN p=1, P=1, LT2")+
  theme_light()

#Plot foresting results
autoplot(ts_LT2_clean) +
  autolayer(NN_LT2_for, series="NN, p=1, P=1") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="LT2")+
  theme_light()

# LT2 NN p=1, P=1 scores
NN_scores_LT2 <- accuracy(NN_LT2_for$mean,LT2_daily_testing)
print(NN_scores_LT2)

# fit NN model to SAL with year of holdout
NN_SAL_fit <- nnetar(SAL_daily_training, p=1, P=1)

# forecast for a year to compare to test dataset 
NN_SAL_for <- forecast(NN_SAL_fit, h= 365)

#Plot model + observed data
autoplot(ts_SAL_clean) +
  autolayer(NN_SAL_fit$fitted, series="Neural Network",PI=FALSE)+
  ylab("depth to groundwater (meters)") +
  labs(title="NN p=1, P=1, SAL")+
  theme_light()

#Plot foresting results
autoplot(ts_SAL_clean) +
  autolayer(NN_SAL_for, series="NN, p=1, P=1") +
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  labs(title="SAL")+
  theme_light()

# SAL NN p=1, P=1 scores
NN_scores_SAL <- accuracy(NN_SAL_for$mean, SAL_daily_testing)
print(NN_scores_SAL)
```

\*\*NOTE PLEASE CHECK THE NAMES OF THESE MODELS TO SEE IF THEYRE RIGHT?? After running the Auto Sarima (SARIMA), the Exponential Smoothing State Space Model (ETS), the Simple Exponential Smoothing (SSES), and the Neural Network (NN) models, we plotted all tested models together on a graph and compared the predicted values for each model to the original data using the accuracy() function.

##### Performance

```{r Comparing Performance Metrics}

#create data frame for LT2 scores
LT2_scores <- as.data.frame(rbind(auto_LT2_scores, ETS_LT2_scores, SSES_LT2_scores, NN_scores_LT2))
row.names(LT2_scores) <- c("SARIMA", "ETS", "SSES", "NN")

#create data frame for SAL scores
SAL_scores <- as.data.frame(rbind(auto_SAL_scores, ETS_SAL_scores, SSES_SAL_scores, NN_scores_SAL))
row.names(SAL_scores) <- c("SARIMA", "ETS", "SSES", "NN")

#choose LT2 model with lowest RMSE #choose a different variable here if you want
best_model_LT2 <- which.min(LT2_scores[,"RMSE"])
cat("The best LT2 Well model by RMSE is:", row.names(LT2_scores[best_model_LT2,]))  

#choose SAL model with lowest RMSE #choose a different variable here if you want
best_model_SAL <- which.min(SAL_scores[,"RMSE"])
cat("The best SAL Well model by RMSE is:", row.names(SAL_scores[best_model_SAL,]))  

#kbl for LT2
kbl(LT2_scores, 
      caption = "Forecast Accuracy for Seasonal Data at Well LT2",
      digits = array(5,ncol(LT2_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(LT2_scores[,"RMSE"]))

#kbl for SAL
kbl(SAL_scores, 
      caption = "Forecast Accuracy for Seasonal Data at Well SAL",
      digits = array(5,ncol(SAL_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(SAL_scores[,"RMSE"]))

```

```{r plot all results}

#LT2 forecast comparison
autoplot(ts_LT2_clean) +
  autolayer(SSES_LT2$forecast, series="SSES") +
  autolayer(ETS_LT2, series = "ETS", PI = FALSE) +
  autolayer(auto_LT2_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_LT2_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Test data forecast comparison LT2")
  
#SAL forecast comparison
autoplot(ts_SAL_clean) +
  autolayer(SSES_SAL$forecast, series="SSES") +
  autolayer(ETS_SAL, series = "ETS", PI = FALSE) +
  autolayer(auto_SAL_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_SAL_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Test data forecast comparison SAL")

#make time series objects for the last two years of data
LT2_depth_end <- LT2_depth %>%
  slice(4749:5295)

SAL_depth_end <- SAL_depth %>%
  slice(4289:4835)

ts_LT2_end <- ts(LT2_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_LT2_end_clean <- tsclean(ts_LT2_end)
ts_SAL_end <- ts(SAL_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_SAL_end_clean <- tsclean(ts_SAL_end)

#LT2 forecast comparison
autoplot(ts_LT2_end_clean) +
  autolayer(SSES_LT2$forecast, series="SSES") +
  autolayer(ETS_LT2, series = "ETS", PI = FALSE) +
  autolayer(auto_LT2_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_LT2_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Test data forecast comparison LT2")
  
#SAL forecast comparison
autoplot(ts_SAL_end_clean) +
  autolayer(SSES_SAL$forecast, series="SSES") +
  autolayer(ETS_SAL, series = "ETS", PI = FALSE) +
  autolayer(auto_SAL_test, series = "SARIMA", PI = FALSE)+
  autolayer(NN_SAL_for, series = "NN")+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="Test data forecast comparison SAL")

```

According to our results, the SARIMA model resulted in the lowest root mean square error (RMSE) for the LT2 well and the ETS model resulted in the lowest RMSE for the SAL well. To continue our analysis, we wanted to improve upon these basic models by adding in exogenous variables and seeing if our RMSE values decreased. For each well, we started by adding rain as an exogenous variable and then added temperature as an exogenous variable in the SARIMA model. Adding the exogenous variables successfully improved the accuracy of our model fit in the last year of data.

##### Improving Performance with Exogenous Variables

```{r create monthly exogenous variables for Sarima}

#subset columns of interest
monthly_reg <- auser_raw %>%
  select(Date:Temperature_Lucca_Orto_Botanico) %>%
  rename(LT2 = Depth_to_Groundwater_LT2,
         SAL = Depth_to_Groundwater_SAL) %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Month) %>%
  summarize_all(mean, na.rm = TRUE) %>%
  select(Month, LT2, SAL, Temperature_Lucca_Orto_Botanico, Rainfall_Gallicano) %>%
  slice(110:268)

#create a dataframe for each regressor that starts at the unique first month of data
temp_reg_monthly <- monthly_reg %>%
  select(Month, Temperature_Lucca_Orto_Botanico)

rain_reg_monthly <- monthly_reg %>%
  select(Month, Rainfall_Gallicano)

LT2_for_reg <- monthly_reg %>%
  select(Month, LT2)

SAL_for_reg <- monthly_reg %>%
  select(Month, SAL)

#create time series objects for monthly averages
ts_LT2_monthly_reg <- tsclean(ts(LT2_for_reg[,2],start=c(2007,04,01),frequency=12))
ts_SAL_monthly_reg <- tsclean(ts(SAL_for_reg[,2],start=c(2007,04,01),frequency=12))
ts_rain_monthly_reg <- tsclean(ts(rain_reg_monthly[,2],start=c(2007,04,01),frequency=12))
ts_temp_monthly_reg <- tsclean(ts(temp_reg_monthly[,2],start=c(2007,04,01),frequency=12))

#plot time series and regressors for visualization
# autoplot(ts_LT2_monthly_reg) +
#   autolayer(ts_SAL_monthly_reg) +
#   autolayer(ts_rain_monthly_reg) +
#   autolayer(ts_temp_monthly_reg) +
#   theme_light()

```

```{r create training and testing sets with the exogenous variables}

n_for_month = 12

LT2_monthly_training_reg <- subset(ts_LT2_monthly_reg, end = length(ts_LT2_monthly_reg) - n_for_month)

LT2_monthly_testing_reg <- subset(ts_LT2_monthly_reg, start = length(ts_LT2_monthly_reg) - n_for_month)

SAL_monthly_training_reg <- subset(ts_SAL_monthly_reg, end = length(ts_SAL_monthly_reg) - n_for_month)

SAL_monthly_testing_reg <- subset(ts_SAL_monthly_reg, start = length(ts_SAL_monthly_reg) - n_for_month)

rain_monthly_training_reg <- subset(ts_rain_monthly_reg, end = length(ts_rain_monthly_reg) - n_for_month)
  
rain_monthly_testing_reg <- subset(ts_rain_monthly_reg, start = length(ts_rain_monthly_reg) - n_for_month)

temp_monthly_training_reg <- subset(ts_temp_monthly_reg, end = length(ts_temp_monthly_reg) - n_for_month)
  
temp_monthly_testing_reg <- subset(ts_temp_monthly_reg, start = length(ts_temp_monthly_reg) - n_for_month)

```

```{r Sarima with exogenous variables for LT2}

#LT2 auto sarima with rainfall regressor
auto_LT2_rain_reg_train <- auto.arima(LT2_monthly_training_reg, xreg=rain_monthly_training_reg)

auto_LT2_rain_reg_test <- forecast(auto_LT2_rain_reg_train, h=12,  xreg=rain_monthly_testing_reg)

#plot foresting results
autoplot(auto_LT2_rain_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima LT2 with Rainfall Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_reg, series = "Original") +
  autolayer(auto_LT2_rain_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2 with Rainfall Regressor") +
  theme_light()

#check the MAPE
auto_LT2_rain_reg_scores <- accuracy(auto_LT2_rain_reg_test$mean, LT2_monthly_testing_reg)
print(auto_LT2_rain_reg_scores)

#LT2 auto sarima with temperature regressor
auto_LT2_temp_reg_train <- auto.arima(LT2_monthly_training_reg, xreg=temp_monthly_training_reg)

auto_LT2_temp_reg_test <- forecast(auto_LT2_temp_reg_train, h=12,  xreg=temp_monthly_testing_reg)

#plot foresting results
autoplot(auto_LT2_temp_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima LT2 with Temperature Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_LT2_monthly_reg, series = "Original") +
  autolayer(auto_LT2_temp_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima LT2 with Temperature Regressor") +
  theme_light()

#check the MAPE
auto_LT2_temp_reg_scores <- accuracy(auto_LT2_temp_reg_test$mean, LT2_monthly_testing_reg)
print(auto_LT2_temp_reg_scores)

```

```{r Sarima with exogenous variables for SAL}

#SAL auto sarima with rainfall regressor
auto_SAL_rain_reg_train <- auto.arima(SAL_monthly_training_reg, xreg=rain_monthly_training_reg)

auto_SAL_rain_reg_test <- forecast(auto_SAL_rain_reg_train, h=12,  xreg=rain_monthly_testing_reg)

#plot foresting results
autoplot(auto_SAL_rain_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima SAL with Rainfall Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_SAL_monthly_reg, series = "Original") +
  autolayer(auto_SAL_rain_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima SAL with Rainfall Regressor") +
  theme_light()

#check the MAPE
auto_SAL_rain_reg_scores <- accuracy(auto_SAL_rain_reg_test$mean, SAL_monthly_testing_reg)
print(auto_SAL_rain_reg_scores)

#SAL auto sarima with temperature regressor
auto_SAL_temp_reg_train <- auto.arima(SAL_monthly_training_reg, xreg=temp_monthly_training_reg)

auto_SAL_temp_reg_test <- forecast(auto_SAL_temp_reg_train, h=12,  xreg=temp_monthly_testing_reg)

#plot foresting results
autoplot(auto_SAL_temp_reg_test)+ 
  ylab("depth to groundwater (meters)") + 
  ggtitle("Auto Sarima SAL with Temperature Regressor") +
  theme_light()

#plot model + observed data
autoplot(ts_SAL_monthly_reg, series = "Original") +
  autolayer(auto_SAL_temp_reg_test, series = "Auto Sarima W/ Reg", PI = FALSE) +
  ylab("depth to groundwater (meters)") +
  ggtitle("Auto Sarima SAL with Temperature Regressor") +
  theme_light()

#check the MAPE
auto_SAL_temp_reg_scores <- accuracy(auto_SAL_temp_reg_test$mean, SAL_monthly_testing_reg)
print(auto_SAL_temp_reg_scores)

```

```{r compare accuracy for all SARIMAs}

#create data frame for LT2 SARIMA scores
LT2_sarima_scores <- as.data.frame(rbind(auto_LT2_scores, 
                                         auto_LT2_rain_reg_scores, 
                                         auto_LT2_temp_reg_scores))
row.names(LT2_sarima_scores) <- c("SARIMA", "SARIMA w/ RAIN", "SARIMA w/ TEMP")

#create data frame for SAL SARIMA scores
SAL_sarima_scores <- as.data.frame(rbind(auto_SAL_scores, 
                                         auto_SAL_rain_reg_scores, 
                                         auto_SAL_temp_reg_scores))
row.names(SAL_sarima_scores) <- c("SARIMA", "SARIMA w/ RAIN", "SARIMA w/ TEMP")

#choose LT2 model with lowest RMSE #choose a different variable here if you want
best_model_LT2_reg <- which.min(LT2_sarima_scores[,"RMSE"])
cat("The best LT2 Well Sarima model by RMSE is:", row.names(LT2_sarima_scores[best_model_LT2_reg,]))  

#choose SAL model with lowest RMSE #choose a different variable here if you want
best_model_SAL_reg <- which.min(SAL_sarima_scores[,"RMSE"])
cat("The best SAL Well Sarima model by RMSE is:", row.names(SAL_sarima_scores[best_model_SAL_reg,]))  

#kbl for LT2 SARIMA
kbl(LT2_sarima_scores, 
      caption = "Forecast Accuracy for Sarima with Regressors at Well LT2",
      digits = array(5,ncol(LT2_sarima_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(LT2_sarima_scores[,"RMSE"]))

#kbl for SAL SARIMA
kbl(SAL_sarima_scores, 
      caption = "Forecast Accuracy for Sarima with Regressors at Well SAL",
      digits = array(5,ncol(SAL_sarima_scores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(SAL_sarima_scores[,"RMSE"]))

```

```{r SARIMA comparison plots}

#make time series objects for the last two years of data
LT2_depth_end <- LT2_depth %>%
  slice(4749:5295)

SAL_depth_end <- SAL_depth %>%
  slice(4289:4835)

ts_LT2_end <- ts(LT2_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_LT2_end_clean <- tsclean(ts_LT2_end)
ts_SAL_end <- ts(SAL_depth_end[,2], start=c(2019,01,01), frequency=365)
ts_SAL_end_clean <- tsclean(ts_SAL_end)

#LT2 forecast comparison
autoplot(ts_LT2_end_clean) +
  autolayer(auto_LT2_test, series = "original", PI = FALSE)+
  autolayer(auto_LT2_rain_reg_test, series = "rain regressor", PI = FALSE)+
  autolayer(auto_LT2_temp_reg_test, series = "temp regressor", PI = FALSE)+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="SARIMA Model Comparisons for LT2")
  
#SAL forecast comparison
autoplot(ts_SAL_end_clean) +
  autolayer(auto_SAL_test, series = "original", PI = FALSE)+
  autolayer(auto_SAL_rain_reg_test, series = "rain regressor", PI = FALSE)+
  autolayer(auto_SAL_temp_reg_test, series = "temp regressor", PI = FALSE)+
  xlab("Year") + ylab("Depth to GW (m)") +
  guides(colour=guide_legend(title="Forecast"))+
  theme_light()+
  labs(title="SARIMA Model Comparisons for LT2")

```

#### Summary and Conclusions

Summarize your major findings from your analyses in a few paragraphs and plots. What conclusions do you draw from your findings? Any insights on how to improve the model?

#### Bibliography

Un world water development report 2022 ‘Groundwater: Making the invisible visible.’ (n.d.). UN-Water. Retrieved April 18, 2024, from <https://www.unwater.org/news/un-world-water-development-report-2022-%E2%80%98groundwater-making-invisible-visible%E2%80%99>

antimo musone, Aredhel Bergström, Federico, Luisa Marotta, Maggie, Maurizio Lucchesi. (2020). Acea Smart Water Analytics. Kaggle. <https://kaggle.com/competitions/acea-water-prediction>
